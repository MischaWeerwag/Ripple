// This file is auto generated by GenerateDefinitions, do not edit by hand
using System;
using System.Buffers;
using System.Collections.ObjectModel;
using System.Text.Json;
using Ibasa.Ripple.St;
namespace Ibasa.Ripple.St
{
    /// <summary>
    /// The type of a transaction (TransactionType field) is the most fundamental information about a transaction.
    /// This indicates what type of operation the transaction is supposed to do.
    /// </summary>
    public enum StTransactionType : ushort
    {
        Invalid = 65535,
        Payment = 0,
        EscrowCreate = 1,
        EscrowFinish = 2,
        AccountSet = 3,
        EscrowCancel = 4,
        SetRegularKey = 5,
        NickNameSet = 6,
        OfferCreate = 7,
        OfferCancel = 8,
        Contract = 9,
        TicketCreate = 10,
        TicketCancel = 11,
        SignerListSet = 12,
        PaymentChannelCreate = 13,
        PaymentChannelFund = 14,
        PaymentChannelClaim = 15,
        CheckCreate = 16,
        CheckCash = 17,
        CheckCancel = 18,
        DepositPreauth = 19,
        TrustSet = 20,
        AccountDelete = 21,
        EnableAmendment = 100,
        SetFee = 101,
        UNLModify = 102,
    }

    /// <summary>
    /// Map of ledger objects to their data type.
    /// These appear in ledger state data, and in the "affected nodes" section of processed transactions' metadata.
    /// </summary>
    public enum StLedgerEntryType
    {
        Any = -3,
        Child = -2,
        Invalid = -1,
        AccountRoot = 97,
        DirectoryNode = 100,
        RippleState = 114,
        Ticket = 84,
        SignerList = 83,
        Offer = 111,
        LedgerHashes = 104,
        Amendments = 102,
        FeeSettings = 115,
        Escrow = 117,
        PayChannel = 120,
        DepositPreauth = 112,
        Check = 67,
        Nickname = 110,
        Contract = 99,
        GeneratorMap = 103,
        NegativeUNL = 78,
    }

    /// <summary>
    /// Map of data types to their "type code" for constructing field IDs and sorting fields in canonical order.
    /// Codes below 1 should not appear in actual data;
    /// codes above 10000 represent special "high-level" object types such as "Transaction" that cannot be serialized inside other objects.
    /// See the Type List for details of how to serialize each type.
    /// </summary>
    public enum StTypeCode
    {
        Validation = 10003,
        Done = -1,
        Hash128 = 4,
        Blob = 7,
        AccountID = 8,
        Amount = 6,
        Hash256 = 5,
        UInt8 = 16,
        Vector256 = 19,
        Object = 14,
        Unknown = -2,
        Transaction = 10001,
        Hash160 = 17,
        PathSet = 18,
        LedgerEntry = 10002,
        UInt16 = 1,
        NotPresent = 0,
        UInt64 = 3,
        UInt32 = 2,
        Array = 15,
    }

    public enum StAccountIDFieldCode
    {
        Account = 1,
        Authorize = 5,
        Destination = 3,
        Issuer = 4,
        Owner = 2,
        RegularKey = 8,
        Target = 7,
        Unauthorize = 6,
    }

    public enum StAmountFieldCode
    {
        Amount = 1,
        Balance = 2,
        DeliverMin = 10,
        DeliveredAmount = 18,
        Fee = 8,
        HighLimit = 7,
        LimitAmount = 3,
        LowLimit = 6,
        MinimumOffer = 16,
        RippleEscrow = 17,
        SendMax = 9,
        TakerGets = 5,
        TakerPays = 4,
        taker_gets_funded = 258,
        taker_pays_funded = 259,
    }

    public enum StArrayFieldCode
    {
        AffectedNodes = 8,
        ArrayEndMarker = 1,
        DisabledValidators = 17,
        Majorities = 16,
        Memos = 9,
        Necessary = 6,
        SignerEntries = 4,
        Signers = 3,
        Sufficient = 7,
        Template = 5,
    }

    public enum StBlobFieldCode
    {
        Condition = 17,
        CreateCode = 11,
        Domain = 7,
        ExpireCode = 10,
        Fulfillment = 16,
        FundCode = 8,
        Generator = 5,
        MasterSignature = 18,
        MemoData = 13,
        MemoFormat = 14,
        MemoType = 12,
        MessageKey = 2,
        PublicKey = 1,
        RemoveCode = 9,
        Signature = 6,
        SigningPubKey = 3,
        TxnSignature = 4,
        UNLModifyValidator = 19,
        ValidatorToDisable = 20,
        ValidatorToReEnable = 21,
    }

    public enum StHash128FieldCode
    {
        EmailHash = 1,
    }

    public enum StHash160FieldCode
    {
        TakerGetsCurrency = 3,
        TakerGetsIssuer = 4,
        TakerPaysCurrency = 1,
        TakerPaysIssuer = 2,
    }

    public enum StHash256FieldCode
    {
        AccountHash = 4,
        AccountTxnID = 9,
        Amendment = 19,
        BookDirectory = 16,
        Channel = 22,
        CheckID = 24,
        ConsensusHash = 23,
        Digest = 21,
        InvoiceID = 17,
        LedgerHash = 1,
        LedgerIndex = 6,
        Nickname = 18,
        ParentHash = 2,
        PreviousTxnID = 5,
        RootIndex = 8,
        TicketID = 20,
        TransactionHash = 3,
        WalletLocator = 7,
        hash = 257,
        index = 258,
    }

    public enum StLedgerEntryFieldCode
    {
        LedgerEntry = 1,
    }

    public enum StObjectFieldCode
    {
        CreatedNode = 3,
        DeletedNode = 4,
        DisabledValidator = 19,
        FinalFields = 7,
        Majority = 18,
        Memo = 10,
        ModifiedNode = 5,
        NewFields = 8,
        ObjectEndMarker = 1,
        PreviousFields = 6,
        Signer = 16,
        SignerEntry = 11,
        TemplateEntry = 9,
        TransactionMetaData = 2,
    }

    public enum StPathSetFieldCode
    {
        Paths = 1,
    }

    public enum StTransactionFieldCode
    {
        Transaction = 1,
    }

    public enum StUInt16FieldCode
    {
        LedgerEntryType = 1,
        SignerWeight = 3,
        TransactionType = 2,
        Version = 16,
    }

    public enum StUInt32FieldCode
    {
        BondAmount = 23,
        CancelAfter = 36,
        ClearFlag = 34,
        CloseTime = 7,
        DestinationTag = 14,
        Expiration = 10,
        FinishAfter = 37,
        FirstLedgerSequence = 26,
        Flags = 2,
        HighQualityIn = 16,
        HighQualityOut = 17,
        LastLedgerSequence = 27,
        LedgerSequence = 6,
        LoadFee = 24,
        LowQualityIn = 18,
        LowQualityOut = 19,
        OfferSequence = 25,
        OperationLimit = 29,
        OwnerCount = 13,
        ParentCloseTime = 8,
        PreviousTxnLgrSeq = 5,
        QualityIn = 20,
        QualityOut = 21,
        ReferenceFeeUnits = 30,
        ReserveBase = 31,
        ReserveIncrement = 32,
        Sequence = 4,
        SetFlag = 33,
        SettleDelay = 39,
        SignerListID = 38,
        SignerQuorum = 35,
        SigningTime = 9,
        SourceTag = 3,
        StampEscrow = 22,
        TicketCount = 40,
        TicketSequence = 41,
        TransactionIndex = 28,
        TransferRate = 11,
        WalletSize = 12,
    }

    public enum StUInt64FieldCode
    {
        BaseFee = 5,
        BookNode = 3,
        DestinationNode = 9,
        ExchangeRate = 6,
        HighNode = 8,
        IndexNext = 1,
        IndexPrevious = 2,
        LowNode = 7,
        OwnerNode = 4,
    }

    public enum StUInt8FieldCode
    {
        CloseResolution = 1,
        Method = 2,
        TickSize = 16,
        TransactionResult = 3,
        UNLModifyDisabling = 17,
    }

    public enum StUnknownFieldCode
    {
        Generic = 0,
        Invalid = -1,
    }

    public enum StValidationFieldCode
    {
        Validation = 1,
    }

    public enum StVector256FieldCode
    {
        Amendments = 3,
        Hashes = 2,
        Indexes = 1,
    }

    public partial struct StFieldId
    {
        public static readonly StFieldId AccountID_Account = new StFieldId(StTypeCode.AccountID, 1);
        public static readonly StFieldId AccountID_Authorize = new StFieldId(StTypeCode.AccountID, 5);
        public static readonly StFieldId AccountID_Destination = new StFieldId(StTypeCode.AccountID, 3);
        public static readonly StFieldId AccountID_Issuer = new StFieldId(StTypeCode.AccountID, 4);
        public static readonly StFieldId AccountID_Owner = new StFieldId(StTypeCode.AccountID, 2);
        public static readonly StFieldId AccountID_RegularKey = new StFieldId(StTypeCode.AccountID, 8);
        public static readonly StFieldId AccountID_Target = new StFieldId(StTypeCode.AccountID, 7);
        public static readonly StFieldId AccountID_Unauthorize = new StFieldId(StTypeCode.AccountID, 6);

        public static readonly StFieldId Amount_Amount = new StFieldId(StTypeCode.Amount, 1);
        public static readonly StFieldId Amount_Balance = new StFieldId(StTypeCode.Amount, 2);
        public static readonly StFieldId Amount_DeliverMin = new StFieldId(StTypeCode.Amount, 10);
        public static readonly StFieldId Amount_DeliveredAmount = new StFieldId(StTypeCode.Amount, 18);
        public static readonly StFieldId Amount_Fee = new StFieldId(StTypeCode.Amount, 8);
        public static readonly StFieldId Amount_HighLimit = new StFieldId(StTypeCode.Amount, 7);
        public static readonly StFieldId Amount_LimitAmount = new StFieldId(StTypeCode.Amount, 3);
        public static readonly StFieldId Amount_LowLimit = new StFieldId(StTypeCode.Amount, 6);
        public static readonly StFieldId Amount_MinimumOffer = new StFieldId(StTypeCode.Amount, 16);
        public static readonly StFieldId Amount_RippleEscrow = new StFieldId(StTypeCode.Amount, 17);
        public static readonly StFieldId Amount_SendMax = new StFieldId(StTypeCode.Amount, 9);
        public static readonly StFieldId Amount_TakerGets = new StFieldId(StTypeCode.Amount, 5);
        public static readonly StFieldId Amount_TakerPays = new StFieldId(StTypeCode.Amount, 4);
        public static readonly StFieldId Amount_taker_gets_funded = new StFieldId(StTypeCode.Amount, 258);
        public static readonly StFieldId Amount_taker_pays_funded = new StFieldId(StTypeCode.Amount, 259);

        public static readonly StFieldId Array_AffectedNodes = new StFieldId(StTypeCode.Array, 8);
        public static readonly StFieldId Array_ArrayEndMarker = new StFieldId(StTypeCode.Array, 1);
        public static readonly StFieldId Array_DisabledValidators = new StFieldId(StTypeCode.Array, 17);
        public static readonly StFieldId Array_Majorities = new StFieldId(StTypeCode.Array, 16);
        public static readonly StFieldId Array_Memos = new StFieldId(StTypeCode.Array, 9);
        public static readonly StFieldId Array_Necessary = new StFieldId(StTypeCode.Array, 6);
        public static readonly StFieldId Array_SignerEntries = new StFieldId(StTypeCode.Array, 4);
        public static readonly StFieldId Array_Signers = new StFieldId(StTypeCode.Array, 3);
        public static readonly StFieldId Array_Sufficient = new StFieldId(StTypeCode.Array, 7);
        public static readonly StFieldId Array_Template = new StFieldId(StTypeCode.Array, 5);

        public static readonly StFieldId Blob_Condition = new StFieldId(StTypeCode.Blob, 17);
        public static readonly StFieldId Blob_CreateCode = new StFieldId(StTypeCode.Blob, 11);
        public static readonly StFieldId Blob_Domain = new StFieldId(StTypeCode.Blob, 7);
        public static readonly StFieldId Blob_ExpireCode = new StFieldId(StTypeCode.Blob, 10);
        public static readonly StFieldId Blob_Fulfillment = new StFieldId(StTypeCode.Blob, 16);
        public static readonly StFieldId Blob_FundCode = new StFieldId(StTypeCode.Blob, 8);
        public static readonly StFieldId Blob_Generator = new StFieldId(StTypeCode.Blob, 5);
        public static readonly StFieldId Blob_MasterSignature = new StFieldId(StTypeCode.Blob, 18);
        public static readonly StFieldId Blob_MemoData = new StFieldId(StTypeCode.Blob, 13);
        public static readonly StFieldId Blob_MemoFormat = new StFieldId(StTypeCode.Blob, 14);
        public static readonly StFieldId Blob_MemoType = new StFieldId(StTypeCode.Blob, 12);
        public static readonly StFieldId Blob_MessageKey = new StFieldId(StTypeCode.Blob, 2);
        public static readonly StFieldId Blob_PublicKey = new StFieldId(StTypeCode.Blob, 1);
        public static readonly StFieldId Blob_RemoveCode = new StFieldId(StTypeCode.Blob, 9);
        public static readonly StFieldId Blob_Signature = new StFieldId(StTypeCode.Blob, 6);
        public static readonly StFieldId Blob_SigningPubKey = new StFieldId(StTypeCode.Blob, 3);
        public static readonly StFieldId Blob_TxnSignature = new StFieldId(StTypeCode.Blob, 4);
        public static readonly StFieldId Blob_UNLModifyValidator = new StFieldId(StTypeCode.Blob, 19);
        public static readonly StFieldId Blob_ValidatorToDisable = new StFieldId(StTypeCode.Blob, 20);
        public static readonly StFieldId Blob_ValidatorToReEnable = new StFieldId(StTypeCode.Blob, 21);

        public static readonly StFieldId Hash128_EmailHash = new StFieldId(StTypeCode.Hash128, 1);

        public static readonly StFieldId Hash160_TakerGetsCurrency = new StFieldId(StTypeCode.Hash160, 3);
        public static readonly StFieldId Hash160_TakerGetsIssuer = new StFieldId(StTypeCode.Hash160, 4);
        public static readonly StFieldId Hash160_TakerPaysCurrency = new StFieldId(StTypeCode.Hash160, 1);
        public static readonly StFieldId Hash160_TakerPaysIssuer = new StFieldId(StTypeCode.Hash160, 2);

        public static readonly StFieldId Hash256_AccountHash = new StFieldId(StTypeCode.Hash256, 4);
        public static readonly StFieldId Hash256_AccountTxnID = new StFieldId(StTypeCode.Hash256, 9);
        public static readonly StFieldId Hash256_Amendment = new StFieldId(StTypeCode.Hash256, 19);
        public static readonly StFieldId Hash256_BookDirectory = new StFieldId(StTypeCode.Hash256, 16);
        public static readonly StFieldId Hash256_Channel = new StFieldId(StTypeCode.Hash256, 22);
        public static readonly StFieldId Hash256_CheckID = new StFieldId(StTypeCode.Hash256, 24);
        public static readonly StFieldId Hash256_ConsensusHash = new StFieldId(StTypeCode.Hash256, 23);
        public static readonly StFieldId Hash256_Digest = new StFieldId(StTypeCode.Hash256, 21);
        public static readonly StFieldId Hash256_InvoiceID = new StFieldId(StTypeCode.Hash256, 17);
        public static readonly StFieldId Hash256_LedgerHash = new StFieldId(StTypeCode.Hash256, 1);
        public static readonly StFieldId Hash256_LedgerIndex = new StFieldId(StTypeCode.Hash256, 6);
        public static readonly StFieldId Hash256_Nickname = new StFieldId(StTypeCode.Hash256, 18);
        public static readonly StFieldId Hash256_ParentHash = new StFieldId(StTypeCode.Hash256, 2);
        public static readonly StFieldId Hash256_PreviousTxnID = new StFieldId(StTypeCode.Hash256, 5);
        public static readonly StFieldId Hash256_RootIndex = new StFieldId(StTypeCode.Hash256, 8);
        public static readonly StFieldId Hash256_TicketID = new StFieldId(StTypeCode.Hash256, 20);
        public static readonly StFieldId Hash256_TransactionHash = new StFieldId(StTypeCode.Hash256, 3);
        public static readonly StFieldId Hash256_WalletLocator = new StFieldId(StTypeCode.Hash256, 7);
        public static readonly StFieldId Hash256_hash = new StFieldId(StTypeCode.Hash256, 257);
        public static readonly StFieldId Hash256_index = new StFieldId(StTypeCode.Hash256, 258);

        public static readonly StFieldId LedgerEntry_LedgerEntry = new StFieldId(StTypeCode.LedgerEntry, 1);

        public static readonly StFieldId Object_CreatedNode = new StFieldId(StTypeCode.Object, 3);
        public static readonly StFieldId Object_DeletedNode = new StFieldId(StTypeCode.Object, 4);
        public static readonly StFieldId Object_DisabledValidator = new StFieldId(StTypeCode.Object, 19);
        public static readonly StFieldId Object_FinalFields = new StFieldId(StTypeCode.Object, 7);
        public static readonly StFieldId Object_Majority = new StFieldId(StTypeCode.Object, 18);
        public static readonly StFieldId Object_Memo = new StFieldId(StTypeCode.Object, 10);
        public static readonly StFieldId Object_ModifiedNode = new StFieldId(StTypeCode.Object, 5);
        public static readonly StFieldId Object_NewFields = new StFieldId(StTypeCode.Object, 8);
        public static readonly StFieldId Object_ObjectEndMarker = new StFieldId(StTypeCode.Object, 1);
        public static readonly StFieldId Object_PreviousFields = new StFieldId(StTypeCode.Object, 6);
        public static readonly StFieldId Object_Signer = new StFieldId(StTypeCode.Object, 16);
        public static readonly StFieldId Object_SignerEntry = new StFieldId(StTypeCode.Object, 11);
        public static readonly StFieldId Object_TemplateEntry = new StFieldId(StTypeCode.Object, 9);
        public static readonly StFieldId Object_TransactionMetaData = new StFieldId(StTypeCode.Object, 2);

        public static readonly StFieldId PathSet_Paths = new StFieldId(StTypeCode.PathSet, 1);

        public static readonly StFieldId Transaction_Transaction = new StFieldId(StTypeCode.Transaction, 1);

        public static readonly StFieldId UInt16_LedgerEntryType = new StFieldId(StTypeCode.UInt16, 1);
        public static readonly StFieldId UInt16_SignerWeight = new StFieldId(StTypeCode.UInt16, 3);
        public static readonly StFieldId UInt16_TransactionType = new StFieldId(StTypeCode.UInt16, 2);
        public static readonly StFieldId UInt16_Version = new StFieldId(StTypeCode.UInt16, 16);

        public static readonly StFieldId UInt32_BondAmount = new StFieldId(StTypeCode.UInt32, 23);
        public static readonly StFieldId UInt32_CancelAfter = new StFieldId(StTypeCode.UInt32, 36);
        public static readonly StFieldId UInt32_ClearFlag = new StFieldId(StTypeCode.UInt32, 34);
        public static readonly StFieldId UInt32_CloseTime = new StFieldId(StTypeCode.UInt32, 7);
        public static readonly StFieldId UInt32_DestinationTag = new StFieldId(StTypeCode.UInt32, 14);
        public static readonly StFieldId UInt32_Expiration = new StFieldId(StTypeCode.UInt32, 10);
        public static readonly StFieldId UInt32_FinishAfter = new StFieldId(StTypeCode.UInt32, 37);
        public static readonly StFieldId UInt32_FirstLedgerSequence = new StFieldId(StTypeCode.UInt32, 26);
        public static readonly StFieldId UInt32_Flags = new StFieldId(StTypeCode.UInt32, 2);
        public static readonly StFieldId UInt32_HighQualityIn = new StFieldId(StTypeCode.UInt32, 16);
        public static readonly StFieldId UInt32_HighQualityOut = new StFieldId(StTypeCode.UInt32, 17);
        public static readonly StFieldId UInt32_LastLedgerSequence = new StFieldId(StTypeCode.UInt32, 27);
        public static readonly StFieldId UInt32_LedgerSequence = new StFieldId(StTypeCode.UInt32, 6);
        public static readonly StFieldId UInt32_LoadFee = new StFieldId(StTypeCode.UInt32, 24);
        public static readonly StFieldId UInt32_LowQualityIn = new StFieldId(StTypeCode.UInt32, 18);
        public static readonly StFieldId UInt32_LowQualityOut = new StFieldId(StTypeCode.UInt32, 19);
        public static readonly StFieldId UInt32_OfferSequence = new StFieldId(StTypeCode.UInt32, 25);
        public static readonly StFieldId UInt32_OperationLimit = new StFieldId(StTypeCode.UInt32, 29);
        public static readonly StFieldId UInt32_OwnerCount = new StFieldId(StTypeCode.UInt32, 13);
        public static readonly StFieldId UInt32_ParentCloseTime = new StFieldId(StTypeCode.UInt32, 8);
        public static readonly StFieldId UInt32_PreviousTxnLgrSeq = new StFieldId(StTypeCode.UInt32, 5);
        public static readonly StFieldId UInt32_QualityIn = new StFieldId(StTypeCode.UInt32, 20);
        public static readonly StFieldId UInt32_QualityOut = new StFieldId(StTypeCode.UInt32, 21);
        public static readonly StFieldId UInt32_ReferenceFeeUnits = new StFieldId(StTypeCode.UInt32, 30);
        public static readonly StFieldId UInt32_ReserveBase = new StFieldId(StTypeCode.UInt32, 31);
        public static readonly StFieldId UInt32_ReserveIncrement = new StFieldId(StTypeCode.UInt32, 32);
        public static readonly StFieldId UInt32_Sequence = new StFieldId(StTypeCode.UInt32, 4);
        public static readonly StFieldId UInt32_SetFlag = new StFieldId(StTypeCode.UInt32, 33);
        public static readonly StFieldId UInt32_SettleDelay = new StFieldId(StTypeCode.UInt32, 39);
        public static readonly StFieldId UInt32_SignerListID = new StFieldId(StTypeCode.UInt32, 38);
        public static readonly StFieldId UInt32_SignerQuorum = new StFieldId(StTypeCode.UInt32, 35);
        public static readonly StFieldId UInt32_SigningTime = new StFieldId(StTypeCode.UInt32, 9);
        public static readonly StFieldId UInt32_SourceTag = new StFieldId(StTypeCode.UInt32, 3);
        public static readonly StFieldId UInt32_StampEscrow = new StFieldId(StTypeCode.UInt32, 22);
        public static readonly StFieldId UInt32_TicketCount = new StFieldId(StTypeCode.UInt32, 40);
        public static readonly StFieldId UInt32_TicketSequence = new StFieldId(StTypeCode.UInt32, 41);
        public static readonly StFieldId UInt32_TransactionIndex = new StFieldId(StTypeCode.UInt32, 28);
        public static readonly StFieldId UInt32_TransferRate = new StFieldId(StTypeCode.UInt32, 11);
        public static readonly StFieldId UInt32_WalletSize = new StFieldId(StTypeCode.UInt32, 12);

        public static readonly StFieldId UInt64_BaseFee = new StFieldId(StTypeCode.UInt64, 5);
        public static readonly StFieldId UInt64_BookNode = new StFieldId(StTypeCode.UInt64, 3);
        public static readonly StFieldId UInt64_DestinationNode = new StFieldId(StTypeCode.UInt64, 9);
        public static readonly StFieldId UInt64_ExchangeRate = new StFieldId(StTypeCode.UInt64, 6);
        public static readonly StFieldId UInt64_HighNode = new StFieldId(StTypeCode.UInt64, 8);
        public static readonly StFieldId UInt64_IndexNext = new StFieldId(StTypeCode.UInt64, 1);
        public static readonly StFieldId UInt64_IndexPrevious = new StFieldId(StTypeCode.UInt64, 2);
        public static readonly StFieldId UInt64_LowNode = new StFieldId(StTypeCode.UInt64, 7);
        public static readonly StFieldId UInt64_OwnerNode = new StFieldId(StTypeCode.UInt64, 4);

        public static readonly StFieldId UInt8_CloseResolution = new StFieldId(StTypeCode.UInt8, 1);
        public static readonly StFieldId UInt8_Method = new StFieldId(StTypeCode.UInt8, 2);
        public static readonly StFieldId UInt8_TickSize = new StFieldId(StTypeCode.UInt8, 16);
        public static readonly StFieldId UInt8_TransactionResult = new StFieldId(StTypeCode.UInt8, 3);
        public static readonly StFieldId UInt8_UNLModifyDisabling = new StFieldId(StTypeCode.UInt8, 17);

        public static readonly StFieldId Unknown_Generic = new StFieldId(StTypeCode.Unknown, 0);
        public static readonly StFieldId Unknown_Invalid = new StFieldId(StTypeCode.Unknown, 4294967295);

        public static readonly StFieldId Validation_Validation = new StFieldId(StTypeCode.Validation, 1);

        public static readonly StFieldId Vector256_Amendments = new StFieldId(StTypeCode.Vector256, 3);
        public static readonly StFieldId Vector256_Hashes = new StFieldId(StTypeCode.Vector256, 2);
        public static readonly StFieldId Vector256_Indexes = new StFieldId(StTypeCode.Vector256, 1);

    }

}
namespace Ibasa.Ripple
{
    public abstract partial class Transaction
    {
      /// <summary>
      /// Read a transaction from a json object.
      /// </summary>
      public static Transaction ReadJson(JsonElement json)
      {
          var transactionType = json.GetProperty("TransactionType").GetString();
          if (transactionType == "AccountSet")
          {
              return new AccountSetTransaction(json);
          }
          else if (transactionType == "AccountDelete")
          {
              return new AccountDeleteTransaction(json);
          }
          else if (transactionType == "CheckCancel")
          {
              return new CheckCancelTransaction(json);
          }
          else if (transactionType == "CheckCash")
          {
              return new CheckCashTransaction(json);
          }
          else if (transactionType == "CheckCreate")
          {
              return new CheckCreateTransaction(json);
          }
          else if (transactionType == "DepositPreauth")
          {
              return new DepositPreauthTransaction(json);
          }
          else if (transactionType == "EscrowCancel")
          {
              return new EscrowCancelTransaction(json);
          }
          else if (transactionType == "EscrowCreate")
          {
              return new EscrowCreateTransaction(json);
          }
          else if (transactionType == "EscrowFinish")
          {
              return new EscrowFinishTransaction(json);
          }
          else if (transactionType == "OfferCancel")
          {
              return new OfferCancelTransaction(json);
          }
          else if (transactionType == "OfferCreate")
          {
              return new OfferCreateTransaction(json);
          }
          else if (transactionType == "Payment")
          {
              return new PaymentTransaction(json);
          }
          else if (transactionType == "PaymentChannelClaim")
          {
              return new PaymentChannelClaimTransaction(json);
          }
          else if (transactionType == "PaymentChannelCreate")
          {
              return new PaymentChannelCreateTransaction(json);
          }
          else if (transactionType == "PaymentChannelFund")
          {
              return new PaymentChannelFundTransaction(json);
          }
          else if (transactionType == "SetRegularKey")
          {
              return new SetRegularKeyTransaction(json);
          }
          else if (transactionType == "SignerListSet")
          {
              return new SignerListSetTransaction(json);
          }
          else if (transactionType == "TicketCreate")
          {
              return new TicketCreateTransaction(json);
          }
          else if (transactionType == "TrustSet")
          {
              return new TrustSetTransaction(json);
          }
          else if (transactionType == "UNLModify")
          {
              return null;
          }
          else
          {
              throw new NotImplementedException(
                  string.Format("Transaction type '{0}' not implemented", transactionType));
          }
      }
    }

    public sealed partial class UnlModifyTransaction : Transaction
    {
        internal UnlModifyTransaction(JsonElement json): base(json) {}
        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            throw new NotImplementedException();
        }
    }
    
    /// <summary>
    /// The AccountRoot object type describes a single account, its settings, and XRP balance.
    /// </summary>
    public sealed partial class AccountRootLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The identifying address of this account, such as rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The account's current XRP balance in drops.
        /// </summary>
        public XrpAmount Balance { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags enabled for this account.
        /// </summary>
        public AccountRootFlags Flags { get; private set; }

        /// <summary>
        /// The number of objects this account owns in the ledger, which contributes to its owner reserve.
        /// </summary>
        public uint OwnerCount { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.)
        /// </summary>
        public uint Sequence { get; private set; }

        /// <summary>
        /// (Optional) The identifying hash of the transaction most recently sent by this account. This field must be enabled to use the AccountTxnID transaction field. To enable it, send an AccountSet transaction with the asfAccountTxnID flag enabled.
        /// </summary>
        public Hash256? AccountTxnID { get; private set; }

        /// <summary>
        /// (Optional) A domain associated with this account. In JSON, this is the hexadecimal for the ASCII representation of the domain.
        /// </summary>
        public ReadOnlyMemory<byte>? Domain { get; private set; }

        /// <summary>
        /// (Optional) The md5 hash of an email address. Clients can use this to look up an avatar through services such as Gravatar.
        /// </summary>
        public Hash128? EmailHash { get; private set; }

        /// <summary>
        /// (Optional) A public key that may be used to send encrypted messages to this account. In JSON, uses hexadecimal. Must be exactly 33 bytes, with the first byte indicating the key type: 0x02 or 0x03 for secp256k1 keys, 0xED for Ed25519 keys.
        /// </summary>
        public ReadOnlyMemory<byte>? MessageKey { get; private set; }

        /// <summary>
        /// (Optional) The address of a key pair that can be used to sign transactions for this account instead of the master key. Use a SetRegularKey transaction to change this value.
        /// </summary>
        public AccountId? RegularKey { get; private set; }

        /// <summary>
        /// (Optional) How many significant digits to use for exchange rates of Offers involving currencies issued by this address. Valid values are 3 to 15, inclusive. (Added by the TickSize amendment.)
        /// </summary>
        public byte? TickSize { get; private set; }

        /// <summary>
        /// (Optional) A transfer fee to charge other users for sending currency issued by this account to each other.
        /// </summary>
        public uint? TransferRate { get; private set; }

        internal AccountRootLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "AccountRoot")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"AccountRoot\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Balance = Ripple.XrpAmount.ReadJson(json.GetProperty("Balance"));
            Flags = (AccountRootFlags)json.GetProperty("Flags").GetUInt32();
            OwnerCount = json.GetProperty("OwnerCount").GetUInt32();
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            Sequence = json.GetProperty("Sequence").GetUInt32();
            if (json.TryGetProperty("AccountTxnID", out element))
            {
                AccountTxnID = new Hash256(element.GetString());
            }
            if (json.TryGetProperty("Domain", out element))
            {
                Domain = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("EmailHash", out element))
            {
                EmailHash = new Hash128(element.GetString());
            }
            if (json.TryGetProperty("MessageKey", out element))
            {
                MessageKey = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("RegularKey", out element))
            {
                RegularKey = new AccountId(element.GetString());
            }
            if (json.TryGetProperty("TickSize", out element))
            {
                TickSize = element.GetByte();
            }
            if (json.TryGetProperty("TransferRate", out element))
            {
                TransferRate = element.GetUInt32();
            }
        }

        internal AccountRootLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (AccountRootFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_TransferRate)
            {
                TransferRate = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_OwnerCount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_OwnerCount, fieldId));
            }
            OwnerCount = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Hash128_EmailHash)
            {
                EmailHash = reader.ReadHash128();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Balance)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Balance, fieldId));
            }
            Balance = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_MessageKey)
            {
                MessageKey = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Domain)
            {
                Domain = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.AccountID_RegularKey)
            {
                RegularKey = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.UInt8_TickSize)
            {
                TickSize = reader.ReadUInt8();
            }
        }

    }

    /// <summary>
    /// The Amendments object type contains a list of Amendments that are currently active. Each ledger version contains at most one Amendments object.
    /// </summary>
    public sealed partial class AmendmentsLedgerEntry : LedgerObject
    {
        /// <summary>
        /// (Optional) Array of 256-bit amendment IDs for all currently-enabled amendments. If omitted, there are no enabled amendments.
        /// </summary>
        public ReadOnlyCollection<Hash256> AmendmentIDs { get; private set; }

        /// <summary>
        /// (Optional) Array of objects describing the status of amendments that have majority support but are not yet enabled. If omitted, there are no pending amendments with majority support.
        /// </summary>
        public ReadOnlyCollection<Majority> Majorities { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for the Amendments object type, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        internal AmendmentsLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Amendments")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Amendments\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("Amendments", out element))
            {
                var AmendmentsArray = new Hash256[element.GetArrayLength()];
                for (int i = 0; i < AmendmentsArray.Length; ++i)
                {
                    AmendmentsArray[i] = new Hash256(element[i].GetString());
                }
                AmendmentIDs = Array.AsReadOnly(AmendmentsArray);
            }
            if (json.TryGetProperty("Majorities", out element))
            {
                var MajoritiesArray = new Majority[element.GetArrayLength()];
                for (int i = 0; i < MajoritiesArray.Length; ++i)
                {
                    MajoritiesArray[i] = new Majority(element[i]);
                }
                Majorities = Array.AsReadOnly(MajoritiesArray);
            }
            Flags = json.GetProperty("Flags").GetUInt32();
        }

        internal AmendmentsLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Majorities)
            {
                var MajoritiesList = new System.Collections.Generic.List<Majority>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Majority)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Majority, fieldId));
                    }
                    MajoritiesList.Add(new Majority(ref reader));
                }
                Majorities = MajoritiesList.AsReadOnly();
            }
            if (fieldId == StFieldId.Vector256_Amendments)
            {
                AmendmentIDs = Array.AsReadOnly(reader.ReadVector256());
            }
        }

    }

    /// <summary>
    /// A Check object describes a check, similar to a paper personal check, which can be cashed by its destination to get money from its sender. (The potential payment has already been approved by its sender, but no money moves until it is cashed. Unlike an Escrow, the money for a Check is not set aside, so cashing the Check could fail due to lack of funds.)
    /// </summary>
    public sealed partial class CheckLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The sender of the Check. Cashing the Check debits this address's balance.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The intended recipient of the Check. Only this address can cash the Check, using a CheckCash transaction.
        /// </summary>
        public AccountId Destination { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for Checks, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// The maximum amount of currency this Check can debit the sender. If the Check is successfully cashed, the destination is credited in the same currency for up to this amount.
        /// </summary>
        public Amount SendMax { get; private set; }

        /// <summary>
        /// The sequence number of the CheckCreate transaction that created this check.
        /// </summary>
        public uint Sequence { get; private set; }

        /// <summary>
        /// (Optional) A hint indicating which page of the destination's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong? DestinationNode { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the destination for this Check, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; private set; }

        /// <summary>
        /// (Optional) Indicates the time after which this Check is considered expired. See Specifying Time for details.
        /// </summary>
        public DateTimeOffset? Expiration { get; private set; }

        /// <summary>
        /// (Optional) Arbitrary 256-bit hash provided by the sender as a specific reason or identifier for this Check.
        /// </summary>
        public Hash256? InvoiceID { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the source for this Check, such as a hosted recipient at the sender's address.
        /// </summary>
        public uint? SourceTag { get; private set; }

        internal CheckLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Check")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Check\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            Flags = json.GetProperty("Flags").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            SendMax = Ripple.Amount.ReadJson(json.GetProperty("SendMax"));
            Sequence = json.GetProperty("Sequence").GetUInt32();
            if (json.TryGetProperty("DestinationNode", out element))
            {
                DestinationNode = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("InvoiceID", out element))
            {
                InvoiceID = new Hash256(element.GetString());
            }
            if (json.TryGetProperty("SourceTag", out element))
            {
                SourceTag = element.GetUInt32();
            }
        }

        internal CheckLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_DestinationNode)
            {
                DestinationNode = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Hash256_InvoiceID)
            {
                InvoiceID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_SendMax)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_SendMax, fieldId));
            }
            SendMax = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
        }

    }

    /// <summary>
    /// A DepositPreauth object tracks a preauthorization from one account to another. DepositPreauth transactions create these objects.
    /// </summary>
    public sealed partial class DepositPreauthLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The account that granted the preauthorization. (The destination of the preauthorized payments.)
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The account that received the preauthorization. (The sender of the preauthorized payments.)
        /// </summary>
        public AccountId Authorize { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for DepositPreauth objects, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal DepositPreauthLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "DepositPreauth")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"DepositPreauth\"", "json");
            }

            Account = new AccountId(json.GetProperty("Account").GetString());
            Authorize = new AccountId(json.GetProperty("Authorize").GetString());
            Flags = json.GetProperty("Flags").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal DepositPreauthLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Authorize)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Authorize, fieldId));
            }
            Authorize = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The DirectoryNode object type provides a list of links to other objects in the ledger's state tree. A single conceptual Directory takes the form of a doubly linked list, with one or more DirectoryNode objects each containing up to 32 IDs of other objects. The first object is called the root of the directory, and all objects other than the root object can be added or deleted as necessary.
    /// </summary>
    public sealed partial class DirectoryNodeLedgerEntry : LedgerObject
    {
        /// <summary>
        /// A bit-map of boolean flags enabled for this directory. Currently, the protocol defines no flags for DirectoryNode objects.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// The ID of root object for this directory.
        /// </summary>
        public Hash256 RootIndex { get; private set; }

        /// <summary>
        /// The contents of this Directory: an array of IDs of other objects.
        /// </summary>
        public ReadOnlyCollection<Hash256> Indexes { get; private set; }

        /// <summary>
        /// (Optional) If this Directory consists of multiple pages, this ID links to the next object in the chain, wrapping around at the end.
        /// </summary>
        public ulong? IndexNext { get; private set; }

        /// <summary>
        /// (Optional) If this Directory consists of multiple pages, this ID links to the previous object in the chain, wrapping around at the beginning.
        /// </summary>
        public ulong? IndexPrevious { get; private set; }

        /// <summary>
        /// (Optional) (Owner Directories only) The address of the account that owns the objects in this directory.
        /// </summary>
        public AccountId? Owner { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) DEPRECATED. Do not use.
        /// </summary>
        public ulong? ExchangeRate { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The currency code of the TakerPays amount from the offers in this directory.
        /// </summary>
        public CurrencyCode? TakerPaysCurrency { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The issuer of the TakerPays amount from the offers in this directory.
        /// </summary>
        public AccountId? TakerPaysIssuer { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The currency code of the TakerGets amount from the offers in this directory.
        /// </summary>
        public CurrencyCode? TakerGetsCurrency { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The issuer of the TakerGets amount from the offers in this directory.
        /// </summary>
        public AccountId? TakerGetsIssuer { get; private set; }

        internal DirectoryNodeLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "DirectoryNode")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"DirectoryNode\"", "json");
            }
            JsonElement element;

            Flags = json.GetProperty("Flags").GetUInt32();
            RootIndex = new Hash256(json.GetProperty("RootIndex").GetString());
            element = json.GetProperty("Indexes");
            var IndexesArray = new Hash256[element.GetArrayLength()];
            for (int i = 0; i < IndexesArray.Length; ++i)
            {
                IndexesArray[i] = new Hash256(element[i].GetString());
            }
            Indexes = Array.AsReadOnly(IndexesArray);
            if (json.TryGetProperty("IndexNext", out element))
            {
                IndexNext = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("IndexPrevious", out element))
            {
                IndexPrevious = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("Owner", out element))
            {
                Owner = new AccountId(element.GetString());
            }
            if (json.TryGetProperty("ExchangeRate", out element))
            {
                ExchangeRate = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("TakerPaysCurrency", out element))
            {
                TakerPaysCurrency = new CurrencyCode(element.GetBytesFromBase16());
            }
            if (json.TryGetProperty("TakerPaysIssuer", out element))
            {
                TakerPaysIssuer = new AccountId(element.GetBytesFromBase16());
            }
            if (json.TryGetProperty("TakerGetsCurrency", out element))
            {
                TakerGetsCurrency = new CurrencyCode(element.GetBytesFromBase16());
            }
            if (json.TryGetProperty("TakerGetsIssuer", out element))
            {
                TakerGetsIssuer = new AccountId(element.GetBytesFromBase16());
            }
        }

        internal DirectoryNodeLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_IndexNext)
            {
                IndexNext = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt64_IndexPrevious)
            {
                IndexPrevious = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt64_ExchangeRate)
            {
                ExchangeRate = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_RootIndex)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_RootIndex, fieldId));
            }
            RootIndex = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.AccountID_Owner)
            {
                Owner = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerPaysCurrency)
            {
                TakerPaysCurrency = ToCurrencyCode(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerPaysIssuer)
            {
                TakerPaysIssuer = ToAccountId(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerGetsCurrency)
            {
                TakerGetsCurrency = ToCurrencyCode(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerGetsIssuer)
            {
                TakerGetsIssuer = ToAccountId(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Vector256_Indexes)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Vector256_Indexes, fieldId));
            }
            Indexes = Array.AsReadOnly(reader.ReadVector256());
        }

    }

    /// <summary>
    /// The Escrow object type represents a held payment of XRP waiting to be executed or canceled. An EscrowCreate transaction creates an Escrow object in the ledger.
    /// </summary>
    public sealed partial class EscrowLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The address of the owner (sender) of this held payment. This is the account that provided the XRP, and gets it back if the held payment is canceled.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The destination address where the XRP is paid if the held payment is successful.
        /// </summary>
        public AccountId Destination { get; private set; }

        /// <summary>
        /// The amount of XRP, in drops, to be delivered by the held payment.
        /// </summary>
        public Amount Amount { get; private set; }

        /// <summary>
        /// (Optional) A PREIMAGE-SHA-256 crypto-condition , as hexadecimal. If present, the EscrowFinish transaction must contain a fulfillment that satisfies this condition.
        /// </summary>
        public ReadOnlyMemory<byte>? Condition { get; private set; }

        /// <summary>
        /// (Optional) The held payment can be canceled if and only if this field is present and the time it specifies has passed. Specifically, this is specified as seconds since the Ripple Epoch and it "has passed" if it's earlier than the close time of the previous validated ledger.
        /// </summary>
        public DateTimeOffset? CancelAfter { get; private set; }

        /// <summary>
        /// (Optional) The time, in seconds since the Ripple Epoch, after which this held payment can be finished. Any EscrowFinish transaction before this time fails. (Specifically, this is compared with the close time of the previous validated ledger.)
        /// </summary>
        public DateTimeOffset? FinishAfter { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner's address.
        /// </summary>
        public uint? SourceTag { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; private set; }

        /// <summary>
        /// (Optional) A hint indicating which page of the destination's owner directory links to this object, in case the directory consists of multiple pages. Omitted on escrows created before enabling the fix1523 amendment.
        /// </summary>
        public ulong? DestinationNode { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal EscrowLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Escrow")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Escrow\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            Amount = Ripple.Amount.ReadJson(json.GetProperty("Amount"));
            if (json.TryGetProperty("Condition", out element))
            {
                Condition = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("CancelAfter", out element))
            {
                CancelAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("FinishAfter", out element))
            {
                FinishAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            Flags = json.GetProperty("Flags").GetUInt32();
            if (json.TryGetProperty("SourceTag", out element))
            {
                SourceTag = element.GetUInt32();
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
            if (json.TryGetProperty("DestinationNode", out element))
            {
                DestinationNode = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal EscrowLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_CancelAfter)
            {
                CancelAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_FinishAfter)
            {
                FinishAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_DestinationNode)
            {
                DestinationNode = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_Condition)
            {
                Condition = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The FeeSettings object type contains the current base transaction cost and reserve amounts as determined by fee voting. Each ledger version contains at most one FeeSettings object.
    /// </summary>
    public sealed partial class FeeSettingsLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The transaction cost of the "reference transaction" in drops of XRP as hexadecimal.
        /// </summary>
        public ulong BaseFee { get; private set; }

        /// <summary>
        /// The BaseFee translated into "fee units".
        /// </summary>
        public uint ReferenceFeeUnits { get; private set; }

        /// <summary>
        /// The base reserve for an account in the XRP Ledger, as drops of XRP.
        /// </summary>
        public uint ReserveBase { get; private set; }

        /// <summary>
        /// The incremental owner reserve for owning objects, as drops of XRP.
        /// </summary>
        public uint ReserveIncrement { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags for this object. No flags are defined for this type.
        /// </summary>
        public uint Flags { get; private set; }

        internal FeeSettingsLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "FeeSettings")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"FeeSettings\"", "json");
            }

            BaseFee = ulong.Parse(json.GetProperty("BaseFee").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            ReferenceFeeUnits = json.GetProperty("ReferenceFeeUnits").GetUInt32();
            ReserveBase = json.GetProperty("ReserveBase").GetUInt32();
            ReserveIncrement = json.GetProperty("ReserveIncrement").GetUInt32();
            Flags = json.GetProperty("Flags").GetUInt32();
        }

        internal FeeSettingsLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_ReferenceFeeUnits)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_ReferenceFeeUnits, fieldId));
            }
            ReferenceFeeUnits = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_ReserveBase)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_ReserveBase, fieldId));
            }
            ReserveBase = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_ReserveIncrement)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_ReserveIncrement, fieldId));
            }
            ReserveIncrement = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_BaseFee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_BaseFee, fieldId));
            }
            BaseFee = reader.ReadUInt64();
        }

    }

    /// <summary>
    /// The LedgerHashes object type contains a history of prior ledgers that led up to this ledger version, in the form of their hashes. Objects of this ledger type are modified automatically in the process of closing a ledger.
    /// </summary>
    public sealed partial class LedgerHashesLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The Ledger Index of the last entry in this object's Hashes array.
        /// </summary>
        public uint LastLedgerSequence { get; private set; }

        /// <summary>
        /// An array of up to 256 ledger hashes. The contents depend on which sub-type of LedgerHashes object this is.
        /// </summary>
        public ReadOnlyCollection<Hash256> Hashes { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags for this object. No flags are defined for this type.
        /// </summary>
        public uint Flags { get; private set; }

        internal LedgerHashesLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "LedgerHashes")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"LedgerHashes\"", "json");
            }
            JsonElement element;

            LastLedgerSequence = json.GetProperty("LastLedgerSequence").GetUInt32();
            element = json.GetProperty("Hashes");
            var HashesArray = new Hash256[element.GetArrayLength()];
            for (int i = 0; i < HashesArray.Length; ++i)
            {
                HashesArray[i] = new Hash256(element[i].GetString());
            }
            Hashes = Array.AsReadOnly(HashesArray);
            Flags = json.GetProperty("Flags").GetUInt32();
        }

        internal LedgerHashesLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_LastLedgerSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_LastLedgerSequence, fieldId));
            }
            LastLedgerSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Vector256_Hashes)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Vector256_Hashes, fieldId));
            }
            Hashes = Array.AsReadOnly(reader.ReadVector256());
        }

    }

    /// <summary>
    /// The NegativeUNL object type contains the current status of the Negative UNL, a list of trusted validators currently believed to be offline.
    /// </summary>
    public sealed partial class NegativeUNLLedgerEntry : LedgerObject
    {
        /// <summary>
        /// (Optional) A list of DisabledValidator objects (see below), each representing a trusted validator that is currently disabled.
        /// </summary>
        public ReadOnlyCollection<DisabledValidator> DisabledValidators { get; private set; }

        /// <summary>
        /// (Optional) The public key of a trusted validator that is scheduled to be disabled in the next flag ledger.
        /// </summary>
        public ReadOnlyMemory<byte>? ValidatorToDisable { get; private set; }

        /// <summary>
        /// (Optional) The public key of a trusted validator in the Negative UNL that is scheduled to be re-enabled in the next flag ledger.
        /// </summary>
        public ReadOnlyMemory<byte>? ValidatorToReEnable { get; private set; }

        internal NegativeUNLLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "NegativeUNL")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"NegativeUNL\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("DisabledValidators", out element))
            {
                var DisabledValidatorsArray = new DisabledValidator[element.GetArrayLength()];
                for (int i = 0; i < DisabledValidatorsArray.Length; ++i)
                {
                    DisabledValidatorsArray[i] = new DisabledValidator(element[i]);
                }
                DisabledValidators = Array.AsReadOnly(DisabledValidatorsArray);
            }
            if (json.TryGetProperty("ValidatorToDisable", out element))
            {
                ValidatorToDisable = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("ValidatorToReEnable", out element))
            {
                ValidatorToReEnable = element.GetBytesFromBase16();
            }
        }

        internal NegativeUNLLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.Blob_ValidatorToDisable)
            {
                ValidatorToDisable = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.Blob_ValidatorToReEnable)
            {
                ValidatorToReEnable = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.Array_DisabledValidators)
            {
                var DisabledValidatorsList = new System.Collections.Generic.List<DisabledValidator>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_DisabledValidator)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_DisabledValidator, fieldId));
                    }
                    DisabledValidatorsList.Add(new DisabledValidator(ref reader));
                }
                DisabledValidators = DisabledValidatorsList.AsReadOnly();
            }
        }

    }

    /// <summary>
    /// The Offer object type describes an offer to exchange currencies, more traditionally known as an order, in the XRP Ledger's distributed exchange. An OfferCreate transaction only creates an Offer object in the ledger when the offer cannot be fully executed immediately by consuming other offers already in the ledger.
    /// </summary>
    public sealed partial class OfferLedgerEntry : LedgerObject
    {
        /// <summary>
        /// A bit-map of boolean flags enabled for this offer.
        /// </summary>
        public OfferFlags Flags { get; private set; }

        /// <summary>
        /// The address of the account that owns this offer.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The Sequence value of the OfferCreate transaction that created this Offer object. Used in combination with the Account to identify this Offer.
        /// </summary>
        public uint Sequence { get; private set; }

        /// <summary>
        /// The remaining amount and type of currency requested by the offer creator.
        /// </summary>
        public Amount TakerPays { get; private set; }

        /// <summary>
        /// The remaining amount and type of currency being provided by the offer creator.
        /// </summary>
        public Amount TakerGets { get; private set; }

        /// <summary>
        /// The ID of the Offer Directory that links to this offer.
        /// </summary>
        public Hash256 BookDirectory { get; private set; }

        /// <summary>
        /// A hint indicating which page of the offer directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong BookNode { get; private set; }

        /// <summary>
        /// (Optional) Indicates the time after which this offer is considered unfunded. See Specifying Time for details.
        /// </summary>
        public DateTimeOffset? Expiration { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal OfferLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Offer")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Offer\"", "json");
            }
            JsonElement element;

            Flags = (OfferFlags)json.GetProperty("Flags").GetUInt32();
            Account = new AccountId(json.GetProperty("Account").GetString());
            Sequence = json.GetProperty("Sequence").GetUInt32();
            TakerPays = Ripple.Amount.ReadJson(json.GetProperty("TakerPays"));
            TakerGets = Ripple.Amount.ReadJson(json.GetProperty("TakerGets"));
            BookDirectory = new Hash256(json.GetProperty("BookDirectory").GetString());
            BookNode = ulong.Parse(json.GetProperty("BookNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal OfferLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (OfferFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_BookNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_BookNode, fieldId));
            }
            BookNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_BookDirectory)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_BookDirectory, fieldId));
            }
            BookDirectory = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_TakerPays)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_TakerPays, fieldId));
            }
            TakerPays = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_TakerGets)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_TakerGets, fieldId));
            }
            TakerGets = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The PayChannel object type represents a payment channel. Payment channels enable small, rapid off-ledger payments of XRP that can be later reconciled with the consensus ledger. A payment channel holds a balance of XRP that can only be paid out to a specific destination address until the channel is closed. Any unspent XRP is returned to the channel's owner (the source address that created and funded it) when the channel closes.
    /// </summary>
    public sealed partial class PayChannelLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The source address that owns this payment channel. This comes from the sending address of the transaction that created the channel.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The destination address for this payment channel. While the payment channel is open, this address is the only one that can receive XRP from the channel. This comes from the Destination field of the transaction that created the channel.
        /// </summary>
        public AccountId Destination { get; private set; }

        /// <summary>
        /// Total XRP, in drops, that has been allocated to this channel. This includes XRP that has been paid to the destination address. This is initially set by the transaction that created the channel and can be increased if the source address sends a PaymentChannelFund transaction.
        /// </summary>
        public Amount Amount { get; private set; }

        /// <summary>
        /// Total XRP, in drops, already paid out by the channel. The difference between this value and the Amount field is how much XRP can still be paid to the destination address with PaymentChannelClaim transactions. If the channel closes, the remaining difference is returned to the source address.
        /// </summary>
        public Amount Balance { get; private set; }

        /// <summary>
        /// Public key, in hexadecimal, of the key pair that can be used to sign claims against this channel. This can be any valid secp256k1 or Ed25519 public key. This is set by the transaction that created the channel and must match the public key used in claims against the channel. The channel source address can also send XRP from this channel to the destination without signed claims.
        /// </summary>
        public ReadOnlyMemory<byte> PublicKey { get; private set; }

        /// <summary>
        /// Number of seconds the source address must wait to close the channel if it still has any XRP in it. Smaller values mean that the destination address has less time to redeem any outstanding claims after the source address requests to close the channel. Can be any value that fits in a 32-bit unsigned integer (0 to 2^32-1). This is set by the transaction that creates the channel.
        /// </summary>
        public TimeSpan SettleDelay { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags enabled for this payment channel. Currently, the protocol defines no flags for PayChannel objects.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// (Optional) A hint indicating which page of the destination's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong? DestinationNode { get; private set; }

        /// <summary>
        /// (Optional) The mutable expiration time for this payment channel, in seconds since the Ripple Epoch. The channel is expired if this value is present and smaller than the previous ledger's close_time field. See Setting Channel Expiration for more details.
        /// </summary>
        public DateTimeOffset? Expiration { get; private set; }

        /// <summary>
        /// (Optional) The immutable expiration time for this payment channel, in seconds since the Ripple Epoch. This channel is expired if this value is present and smaller than the previous ledger's close_time field. This is optionally set by the transaction that created the channel, and cannot be changed.
        /// </summary>
        public DateTimeOffset? CancelAfter { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the source for this payment channel, such as a hosted recipient at the owner's address.
        /// </summary>
        public uint? SourceTag { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the destination for this payment channel, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; private set; }

        internal PayChannelLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "PayChannel")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"PayChannel\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            Amount = Ripple.Amount.ReadJson(json.GetProperty("Amount"));
            Balance = Ripple.Amount.ReadJson(json.GetProperty("Balance"));
            PublicKey = json.GetProperty("PublicKey").GetBytesFromBase16();
            SettleDelay = TimeSpan.FromSeconds(json.GetProperty("SettleDelay").GetUInt32());
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            Flags = json.GetProperty("Flags").GetUInt32();
            if (json.TryGetProperty("DestinationNode", out element))
            {
                DestinationNode = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("CancelAfter", out element))
            {
                CancelAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("SourceTag", out element))
            {
                SourceTag = element.GetUInt32();
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
        }

        internal PayChannelLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_CancelAfter)
            {
                CancelAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_SettleDelay)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SettleDelay, fieldId));
            }
            SettleDelay = TimeSpan.FromSeconds(reader.ReadUInt32());
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_DestinationNode)
            {
                DestinationNode = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Balance)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Balance, fieldId));
            }
            Balance = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_PublicKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_PublicKey, fieldId));
            }
            PublicKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The RippleState object type connects two accounts in a single currency. Conceptually, a RippleState object represents two trust lines between the accounts, one from each side. Each account can change the settings for its side of the RippleState object, but the balance is a single shared value. A trust line that is entirely in its default state is considered the same as a trust line that does not exist, so rippled deletes RippleState objects when their properties are entirely default.
    /// </summary>
    public sealed partial class RippleStateLedgerEntry : LedgerObject
    {
        /// <summary>
        /// A bit-map of boolean options enabled for this object.
        /// </summary>
        public RippleStateFlags Flags { get; private set; }

        /// <summary>
        /// The balance of the trust line, from the perspective of the low account. A negative balance indicates that the low account has issued currency to the high account. The issuer in this is always set to the neutral value ACCOUNT_ONE.
        /// </summary>
        public IssuedAmount Balance { get; private set; }

        /// <summary>
        /// The limit that the low account has set on the trust line. The issuer is the address of the low account that set this limit.
        /// </summary>
        public IssuedAmount LowLimit { get; private set; }

        /// <summary>
        /// The limit that the high account has set on the trust line. The issuer is the address of the high account that set this limit.
        /// </summary>
        public IssuedAmount HighLimit { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// (Omitted in some historical ledgers) A hint indicating which page of the low account's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong LowNode { get; private set; }

        /// <summary>
        /// (Omitted in some historical ledgers) A hint indicating which page of the high account's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong HighNode { get; private set; }

        /// <summary>
        /// (Optional) The inbound quality set by the low account, as an integer in the implied ratio LowQualityIn:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? LowQualityIn { get; private set; }

        /// <summary>
        /// (Optional) The outbound quality set by the low account, as an integer in the implied ratio LowQualityOut:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? LowQualityOut { get; private set; }

        /// <summary>
        /// (Optional) The inbound quality set by the high account, as an integer in the implied ratio HighQualityIn:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? HighQualityIn { get; private set; }

        /// <summary>
        /// (Optional) The outbound quality set by the high account, as an integer in the implied ratio HighQualityOut:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? HighQualityOut { get; private set; }

        internal RippleStateLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "RippleState")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"RippleState\"", "json");
            }
            JsonElement element;

            Flags = (RippleStateFlags)json.GetProperty("Flags").GetUInt32();
            Balance = Ripple.IssuedAmount.ReadJson(json.GetProperty("Balance"));
            LowLimit = Ripple.IssuedAmount.ReadJson(json.GetProperty("LowLimit"));
            HighLimit = Ripple.IssuedAmount.ReadJson(json.GetProperty("HighLimit"));
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            LowNode = ulong.Parse(json.GetProperty("LowNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            HighNode = ulong.Parse(json.GetProperty("HighNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            if (json.TryGetProperty("LowQualityIn", out element))
            {
                LowQualityIn = element.GetUInt32();
            }
            if (json.TryGetProperty("LowQualityOut", out element))
            {
                LowQualityOut = element.GetUInt32();
            }
            if (json.TryGetProperty("HighQualityIn", out element))
            {
                HighQualityIn = element.GetUInt32();
            }
            if (json.TryGetProperty("HighQualityOut", out element))
            {
                HighQualityOut = element.GetUInt32();
            }
        }

        internal RippleStateLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (RippleStateFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_HighQualityIn)
            {
                HighQualityIn = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_HighQualityOut)
            {
                HighQualityOut = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LowQualityIn)
            {
                LowQualityIn = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LowQualityOut)
            {
                LowQualityOut = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_LowNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_LowNode, fieldId));
            }
            LowNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_HighNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_HighNode, fieldId));
            }
            HighNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Balance)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Balance, fieldId));
            }
            Balance = reader.ReadIssuedAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_LowLimit)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_LowLimit, fieldId));
            }
            LowLimit = reader.ReadIssuedAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_HighLimit)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_HighLimit, fieldId));
            }
            HighLimit = reader.ReadIssuedAmount();
        }

    }

    /// <summary>
    /// The SignerList object type represents a list of parties that, as a group, are authorized to sign a transaction in place of an individual account. You can create, replace, or remove a signer list using a SignerListSet transaction.
    /// </summary>
    public sealed partial class SignerListLedgerEntry : LedgerObject
    {
        /// <summary>
        /// A bit-map of Boolean flags enabled for this signer list. For more information, see SignerList Flags.
        /// </summary>
        public SignerListFlags Flags { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// An array of Signer Entry objects representing the parties who are part of this signer list.
        /// </summary>
        public ReadOnlyCollection<SignerEntry> SignerEntries { get; private set; }

        /// <summary>
        /// An ID for this signer list. Currently always set to 0. If a future amendment allows multiple signer lists for an account, this may change.
        /// </summary>
        public uint SignerListID { get; private set; }

        /// <summary>
        /// A target number for signer weights. To produce a valid signature for the owner of this SignerList, the signers must provide valid signatures whose weights sum to this value or more.
        /// </summary>
        public uint SignerQuorum { get; private set; }

        internal SignerListLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "SignerList")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"SignerList\"", "json");
            }
            JsonElement element;

            Flags = (SignerListFlags)json.GetProperty("Flags").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            element = json.GetProperty("SignerEntries");
            var SignerEntriesArray = new SignerEntry[element.GetArrayLength()];
            for (int i = 0; i < SignerEntriesArray.Length; ++i)
            {
                SignerEntriesArray[i] = new SignerEntry(element[i]);
            }
            SignerEntries = Array.AsReadOnly(SignerEntriesArray);
            SignerListID = json.GetProperty("SignerListID").GetUInt32();
            SignerQuorum = json.GetProperty("SignerQuorum").GetUInt32();
        }

        internal SignerListLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (SignerListFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_SignerQuorum)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SignerQuorum, fieldId));
            }
            SignerQuorum = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_SignerListID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SignerListID, fieldId));
            }
            SignerListID = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Array_SignerEntries)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Array_SignerEntries, fieldId));
            }
            var SignerEntriesList = new System.Collections.Generic.List<SignerEntry>();
            while (true)
            {
                fieldId = reader.ReadFieldId();
                if (fieldId == StFieldId.Array_ArrayEndMarker)
                {
                    break;
                }
                if (fieldId != StFieldId.Object_SignerEntry)
                {
                    throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_SignerEntry, fieldId));
                }
                SignerEntriesList.Add(new SignerEntry(ref reader));
            }
            SignerEntries = SignerEntriesList.AsReadOnly();
        }

    }

    /// <summary>
    /// The Ticket object type represents a Ticket, which tracks an account sequence number that has been set aside for future use. You can create new tickets with a TicketCreate transaction. New in: rippled 1.7.0 
    /// </summary>
    public sealed partial class TicketLedgerEntry : LedgerObject
    {
        /// <summary>
        /// The account that owns this Ticket.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// A bit-map of Boolean flags enabled for this Ticket. Currently, there are no flags defined for Tickets.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// The Sequence Number this Ticket sets aside.
        /// </summary>
        public uint TicketSequence { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal TicketLedgerEntry(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Ticket")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Ticket\"", "json");
            }

            Account = new AccountId(json.GetProperty("Account").GetString());
            Flags = json.GetProperty("Flags").GetUInt32();
            TicketSequence = json.GetProperty("TicketSequence").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal TicketLedgerEntry(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_TicketSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_TicketSequence, fieldId));
            }
            TicketSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
        }

    }

    /// <summary>
    /// An AccountSet transaction modifies the properties of an account in the XRP Ledger.
    /// </summary>
    public sealed partial class AccountSetTransaction : Transaction
    {
        /// <summary>
        /// (Optional) Unique identifier of a flag to disable for this account.
        /// </summary>
        public AccountSetFlags? ClearFlag { get; set; }

        /// <summary>
        /// (Optional) The domain that owns this account, as a string of hex representing the ASCII for the domain in lowercase. Cannot be more than 256 bytes in length. 
        /// </summary>
        public ReadOnlyMemory<byte>? Domain { get; set; }

        /// <summary>
        /// (Optional) Hash of an email address to be used for generating an avatar image. Conventionally, clients use Gravatar to display this image.
        /// </summary>
        public Hash128? EmailHash { get; set; }

        /// <summary>
        /// (Optional) Public key for sending encrypted messages to this account. To set the key, it must be exactly 33 bytes, with the first byte indicating the key type: 0x02 or 0x03 for secp256k1 keys, 0xED for Ed25519 keys. To remove the key, use an empty value.
        /// </summary>
        public ReadOnlyMemory<byte>? MessageKey { get; set; }

        /// <summary>
        /// (Optional) Integer flag to enable for this account.
        /// </summary>
        public AccountSetFlags? SetFlag { get; set; }

        /// <summary>
        /// (Optional) The fee to charge when users transfer this account's issued currencies, represented as billionths of a unit. Cannot be more than 2000000000 or less than 1000000000, except for the special case 0 meaning no fee.
        /// </summary>
        public uint? TransferRate { get; set; }

        /// <summary>
        /// (Optional) Tick size to use for offers involving a currency issued by this address. The exchange rates of those offers is rounded to this many significant digits. Valid values are 3 to 15 inclusive, or 0 to disable. (Added by the TickSize amendment.)
        /// </summary>
        public byte? TickSize { get; set; }

        public AccountSetTransaction()
        {
        }

        internal AccountSetTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "AccountSet")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"AccountSet\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("ClearFlag", out element))
            {
                ClearFlag = (AccountSetFlags)element.GetUInt32();
            }
            if (json.TryGetProperty("Domain", out element))
            {
                Domain = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("EmailHash", out element))
            {
                EmailHash = new Hash128(element.GetString());
            }
            if (json.TryGetProperty("MessageKey", out element))
            {
                MessageKey = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("SetFlag", out element))
            {
                SetFlag = (AccountSetFlags)element.GetUInt32();
            }
            if (json.TryGetProperty("TransferRate", out element))
            {
                TransferRate = element.GetUInt32();
            }
            if (json.TryGetProperty("TickSize", out element))
            {
                TickSize = element.GetByte();
            }
        }

        internal AccountSetTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_TransferRate)
            {
                TransferRate = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SetFlag)
            {
                SetFlag = (AccountSetFlags)reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_ClearFlag)
            {
                ClearFlag = (AccountSetFlags)reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash128_EmailHash)
            {
                EmailHash = reader.ReadHash128();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_MessageKey)
            {
                MessageKey = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Domain)
            {
                Domain = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
            if (fieldId == StFieldId.UInt8_TickSize)
            {
                TickSize = reader.ReadUInt8();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.AccountSet);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (TransferRate != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TransferRate, TransferRate.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (SetFlag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SetFlag, (uint)SetFlag.Value);
            }
            if (ClearFlag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.ClearFlag, (uint)ClearFlag.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (EmailHash != null)
            {
                writer.WriteHash128(StHash128FieldCode.EmailHash, EmailHash.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            if (MessageKey != null)
            {
                writer.WriteBlob(StBlobFieldCode.MessageKey, MessageKey.Value.Span);
            }
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            if (Domain != null)
            {
                writer.WriteBlob(StBlobFieldCode.Domain, Domain.Value.Span);
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
            if (TickSize != null)
            {
                writer.WriteUInt8(StUInt8FieldCode.TickSize, TickSize.Value);
            }
        }
    }

    /// <summary>
    /// An AccountDelete transaction deletes an account and any objects it owns in the XRP Ledger, if possible, sending the account's remaining XRP to a specified destination account. See Deletion of Accounts for the requirements to delete an account.
    /// </summary>
    public sealed partial class AccountDeleteTransaction : Transaction
    {
        /// <summary>
        /// The address of an account to receive any leftover XRP after deleting the sending account. Must be a funded account in the ledger, and must not be the sending account.
        /// </summary>
        public AccountId Destination { get; set; }

        /// <summary>
        /// (Optional) Arbitrary destination tag that identifies a hosted recipient or other information for the recipient of the deleted account's leftover XRP.
        /// </summary>
        public uint? DestinationTag { get; set; }

        public AccountDeleteTransaction()
        {
        }

        internal AccountDeleteTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "AccountDelete")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"AccountDelete\"", "json");
            }
            JsonElement element;

            Destination = new AccountId(json.GetProperty("Destination").GetString());
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
        }

        internal AccountDeleteTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.AccountDelete);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (DestinationTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.DestinationTag, DestinationTag.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Destination, Destination);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Cancels an unredeemed Check, removing it from the ledger without sending any money. The source or the destination of the check can cancel a Check at any time using this transaction type. If the Check has expired, any address can cancel it.
    /// </summary>
    public sealed partial class CheckCancelTransaction : Transaction
    {
        /// <summary>
        /// The ID of the Check ledger object to cancel, as a 64-character hexadecimal string.
        /// </summary>
        public Hash256 CheckID { get; set; }

        public CheckCancelTransaction()
        {
        }

        internal CheckCancelTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "CheckCancel")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"CheckCancel\"", "json");
            }

            CheckID = new Hash256(json.GetProperty("CheckID").GetString());
        }

        internal CheckCancelTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_CheckID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_CheckID, fieldId));
            }
            CheckID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.CheckCancel);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteHash256(StHash256FieldCode.CheckID, CheckID);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Attempts to redeem a Check object in the ledger to receive up to the amount authorized by the corresponding CheckCreate transaction. Only the Destination address of a Check can cash it with a CheckCash transaction. Cashing a check this way is similar to executing a Payment initiated by the destination.
    /// </summary>
    public sealed partial class CheckCashTransaction : Transaction
    {
        /// <summary>
        /// The ID of the Check ledger object to cash, as a 64-character hexadecimal string.
        /// </summary>
        public Hash256 CheckID { get; set; }

        /// <summary>
        /// (Optional) Redeem the Check for exactly this amount, if possible. The currency must match that of the SendMax of the corresponding CheckCreate transaction. You must provide either this field or DeliverMin.
        /// </summary>
        public Amount? Amount { get; set; }

        /// <summary>
        /// (Optional) Redeem the Check for at least this amount and for as much as possible. The currency must match that of the SendMax of the corresponding CheckCreate transaction. You must provide either this field or Amount.
        /// </summary>
        public Amount? DeliverMin { get; set; }

        public CheckCashTransaction()
        {
        }

        internal CheckCashTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "CheckCash")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"CheckCash\"", "json");
            }
            JsonElement element;

            CheckID = new Hash256(json.GetProperty("CheckID").GetString());
            if (json.TryGetProperty("Amount", out element))
            {
                Amount = Ripple.Amount.ReadJson(element);
            }
            if (json.TryGetProperty("DeliverMin", out element))
            {
                DeliverMin = Ripple.Amount.ReadJson(element);
            }
        }

        internal CheckCashTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_CheckID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_CheckID, fieldId));
            }
            CheckID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Amount_Amount)
            {
                Amount = reader.ReadAmount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Amount_DeliverMin)
            {
                DeliverMin = reader.ReadAmount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.CheckCash);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteHash256(StHash256FieldCode.CheckID, CheckID);
            if (Amount != null)
            {
                writer.WriteAmount(StAmountFieldCode.Amount, Amount.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            if (DeliverMin != null)
            {
                writer.WriteAmount(StAmountFieldCode.DeliverMin, DeliverMin.Value);
            }
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Create a Check object in the ledger, which is a deferred payment that can be cashed by its intended destination. The sender of this transaction is the sender of the Check.
    /// </summary>
    public sealed partial class CheckCreateTransaction : Transaction
    {
        /// <summary>
        /// The unique address of the account that can cash the Check.
        /// </summary>
        public AccountId Destination { get; set; }

        /// <summary>
        /// Maximum amount of source currency the Check is allowed to debit the sender, including transfer fees on non-XRP currencies. The Check can only credit the destination with the same currency (from the same issuer, for non-XRP currencies). For non-XRP amounts, the nested field names MUST be lower-case.
        /// </summary>
        public Amount SendMax { get; set; }

        /// <summary>
        /// (Optional) Arbitrary tag that identifies the reason for the Check, or a hosted recipient to pay.
        /// </summary>
        public uint? DestinationTag { get; set; }

        /// <summary>
        /// (Optional) Time after which the Check is no longer valid, in seconds since the Ripple Epoch.
        /// </summary>
        public DateTimeOffset? Expiration { get; set; }

        /// <summary>
        /// (Optional) Arbitrary 256-bit hash representing a specific reason or identifier for this Check.
        /// </summary>
        public Hash256? InvoiceID { get; set; }

        public CheckCreateTransaction()
        {
        }

        internal CheckCreateTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "CheckCreate")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"CheckCreate\"", "json");
            }
            JsonElement element;

            Destination = new AccountId(json.GetProperty("Destination").GetString());
            SendMax = Ripple.Amount.ReadJson(json.GetProperty("SendMax"));
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("InvoiceID", out element))
            {
                InvoiceID = new Hash256(element.GetString());
            }
        }

        internal CheckCreateTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_InvoiceID)
            {
                InvoiceID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_SendMax)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_SendMax, fieldId));
            }
            SendMax = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.CheckCreate);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (Expiration != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.Expiration, Epoch.FromDateTimeOffset(Expiration.Value));
            }
            if (DestinationTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.DestinationTag, DestinationTag.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            if (InvoiceID != null)
            {
                writer.WriteHash256(StHash256FieldCode.InvoiceID, InvoiceID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteAmount(StAmountFieldCode.SendMax, SendMax);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Destination, Destination);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// A DepositPreauth transaction gives another account pre-approval to deliver payments to the sender of this transaction. This is only useful if the sender of this transaction is using (or plans to use) Deposit Authorization.
    /// </summary>
    public sealed partial class DepositPreauthTransaction : Transaction
    {
        /// <summary>
        /// (Optional) The XRP Ledger address of the sender to preauthorize.
        /// </summary>
        public AccountId? Authorize { get; set; }

        /// <summary>
        /// (Optional) The XRP Ledger address of a sender whose preauthorization should be revoked.
        /// </summary>
        public AccountId? Unauthorize { get; set; }

        public DepositPreauthTransaction()
        {
        }

        internal DepositPreauthTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "DepositPreauth")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"DepositPreauth\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("Authorize", out element))
            {
                Authorize = new AccountId(element.GetString());
            }
            if (json.TryGetProperty("Unauthorize", out element))
            {
                Unauthorize = new AccountId(element.GetString());
            }
        }

        internal DepositPreauthTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.AccountID_Authorize)
            {
                Authorize = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.AccountID_Unauthorize)
            {
                Unauthorize = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.DepositPreauth);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (Authorize != null)
            {
                writer.WriteAccount(StAccountIDFieldCode.Authorize, Authorize.Value);
            }
            if (Unauthorize != null)
            {
                writer.WriteAccount(StAccountIDFieldCode.Unauthorize, Unauthorize.Value);
            }
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Return escrowed XRP to the sender.
    /// </summary>
    public sealed partial class EscrowCancelTransaction : Transaction
    {
        /// <summary>
        /// Address of the source account that funded the escrow payment.
        /// </summary>
        public AccountId Owner { get; set; }

        /// <summary>
        /// Transaction sequence (or Ticket number) of EscrowCreate transaction that created the escrow to cancel.
        /// </summary>
        public uint OfferSequence { get; set; }

        public EscrowCancelTransaction()
        {
        }

        internal EscrowCancelTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "EscrowCancel")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"EscrowCancel\"", "json");
            }

            Owner = new AccountId(json.GetProperty("Owner").GetString());
            OfferSequence = json.GetProperty("OfferSequence").GetUInt32();
        }

        internal EscrowCancelTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_OfferSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_OfferSequence, fieldId));
            }
            OfferSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Owner)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Owner, fieldId));
            }
            Owner = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.EscrowCancel);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            writer.WriteUInt32(StUInt32FieldCode.OfferSequence, OfferSequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Owner, Owner);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Sequester XRP until the escrow process either finishes or is canceled.
    /// </summary>
    public sealed partial class EscrowCreateTransaction : Transaction
    {
        /// <summary>
        /// Amount of XRP, in drops, to deduct from the sender's balance and escrow. Once escrowed, the XRP can either go to the Destination address (after the FinishAfter time) or returned to the sender (after the CancelAfter time).
        /// </summary>
        public XrpAmount Amount { get; set; }

        /// <summary>
        /// Address to receive escrowed XRP.
        /// </summary>
        public AccountId Destination { get; set; }

        /// <summary>
        /// (Optional) The time, in seconds since the Ripple Epoch, when this escrow expires. This value is immutable; the funds can only be returned the sender after this time.
        /// </summary>
        public DateTimeOffset? CancelAfter { get; set; }

        /// <summary>
        /// (Optional) The time, in seconds since the Ripple Epoch, when the escrowed XRP can be released to the recipient. This value is immutable; the funds cannot move until this time is reached.
        /// </summary>
        public DateTimeOffset? FinishAfter { get; set; }

        /// <summary>
        /// (Optional) Hex value representing a PREIMAGE-SHA-256 crypto-condition. The funds can only be delivered to the recipient if this condition is fulfilled.
        /// </summary>
        public ReadOnlyMemory<byte>? Condition { get; set; }

        /// <summary>
        /// (Optional) Arbitrary tag to further specify the destination for this escrowed payment, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; set; }

        public EscrowCreateTransaction()
        {
        }

        internal EscrowCreateTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "EscrowCreate")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"EscrowCreate\"", "json");
            }
            JsonElement element;

            Amount = Ripple.XrpAmount.ReadJson(json.GetProperty("Amount"));
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            if (json.TryGetProperty("CancelAfter", out element))
            {
                CancelAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("FinishAfter", out element))
            {
                FinishAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("Condition", out element))
            {
                Condition = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
        }

        internal EscrowCreateTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_CancelAfter)
            {
                CancelAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_FinishAfter)
            {
                FinishAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Condition)
            {
                Condition = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.EscrowCreate);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (DestinationTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.DestinationTag, DestinationTag.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (CancelAfter != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.CancelAfter, Epoch.FromDateTimeOffset(CancelAfter.Value));
            }
            if (FinishAfter != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.FinishAfter, Epoch.FromDateTimeOffset(FinishAfter.Value));
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Amount, Amount);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            if (Condition != null)
            {
                writer.WriteBlob(StBlobFieldCode.Condition, Condition.Value.Span);
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Destination, Destination);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Deliver XRP from a held payment to the recipient.
    /// </summary>
    public sealed partial class EscrowFinishTransaction : Transaction
    {
        /// <summary>
        /// Address of the source account that funded the held payment.
        /// </summary>
        public AccountId Owner { get; set; }

        /// <summary>
        /// Transaction sequence of EscrowCreate transaction that created the held payment to finish.
        /// </summary>
        public uint OfferSequence { get; set; }

        /// <summary>
        /// (Optional) Hex value matching the previously-supplied PREIMAGE-SHA-256 crypto-condition of the held payment.
        /// </summary>
        public ReadOnlyMemory<byte>? Condition { get; set; }

        /// <summary>
        /// (Optional) Hex value of the PREIMAGE-SHA-256 crypto-condition fulfillment matching the held payment's Condition.
        /// </summary>
        public ReadOnlyMemory<byte>? Fulfillment { get; set; }

        public EscrowFinishTransaction()
        {
        }

        internal EscrowFinishTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "EscrowFinish")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"EscrowFinish\"", "json");
            }
            JsonElement element;

            Owner = new AccountId(json.GetProperty("Owner").GetString());
            OfferSequence = json.GetProperty("OfferSequence").GetUInt32();
            if (json.TryGetProperty("Condition", out element))
            {
                Condition = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("Fulfillment", out element))
            {
                Fulfillment = element.GetBytesFromBase16();
            }
        }

        internal EscrowFinishTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_OfferSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_OfferSequence, fieldId));
            }
            OfferSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Fulfillment)
            {
                Fulfillment = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Condition)
            {
                Condition = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Owner)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Owner, fieldId));
            }
            Owner = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.EscrowFinish);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            writer.WriteUInt32(StUInt32FieldCode.OfferSequence, OfferSequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            if (Fulfillment != null)
            {
                writer.WriteBlob(StBlobFieldCode.Fulfillment, Fulfillment.Value.Span);
            }
            if (Condition != null)
            {
                writer.WriteBlob(StBlobFieldCode.Condition, Condition.Value.Span);
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Owner, Owner);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// An OfferCancel transaction removes an Offer object from the XRP Ledger.
    /// </summary>
    public sealed partial class OfferCancelTransaction : Transaction
    {
        /// <summary>
        /// The sequence number (or Ticket  number) of a previous OfferCreate transaction. If specified, cancel any offer object in the ledger that was created by that transaction. It is not considered an error if the offer specified does not exist.
        /// </summary>
        public uint OfferSequence { get; set; }

        public OfferCancelTransaction()
        {
        }

        internal OfferCancelTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "OfferCancel")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"OfferCancel\"", "json");
            }

            OfferSequence = json.GetProperty("OfferSequence").GetUInt32();
        }

        internal OfferCancelTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_OfferSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_OfferSequence, fieldId));
            }
            OfferSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.OfferCancel);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            writer.WriteUInt32(StUInt32FieldCode.OfferSequence, OfferSequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// An OfferCreate transaction is effectively a limit order. It defines an intent to exchange currencies, and creates an Offer object if not completely fulfilled when placed. Offers can be partially fulfilled.
    /// </summary>
    public sealed partial class OfferCreateTransaction : Transaction
    {
        /// <summary>
        /// The amount and type of currency being provided by the offer creator.
        /// </summary>
        public Amount TakerGets { get; set; }

        /// <summary>
        /// The amount and type of currency being requested by the offer creator.
        /// </summary>
        public Amount TakerPays { get; set; }

        /// <summary>
        /// (Optional) Time after which the offer is no longer active, in seconds since the Ripple Epoch.
        /// </summary>
        public DateTimeOffset? Expiration { get; set; }

        /// <summary>
        /// (Optional) An offer to delete first, specified in the same way as OfferCancel.
        /// </summary>
        public uint? OfferSequence { get; set; }

        public OfferCreateTransaction()
        {
        }

        internal OfferCreateTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "OfferCreate")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"OfferCreate\"", "json");
            }
            JsonElement element;

            TakerGets = Ripple.Amount.ReadJson(json.GetProperty("TakerGets"));
            TakerPays = Ripple.Amount.ReadJson(json.GetProperty("TakerPays"));
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("OfferSequence", out element))
            {
                OfferSequence = element.GetUInt32();
            }
        }

        internal OfferCreateTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_OfferSequence)
            {
                OfferSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_TakerPays)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_TakerPays, fieldId));
            }
            TakerPays = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_TakerGets)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_TakerGets, fieldId));
            }
            TakerGets = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.OfferCreate);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (Expiration != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.Expiration, Epoch.FromDateTimeOffset(Expiration.Value));
            }
            if (OfferSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.OfferSequence, OfferSequence.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.TakerPays, TakerPays);
            writer.WriteAmount(StAmountFieldCode.TakerGets, TakerGets);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// A Payment transaction represents a transfer of value from one account to another. (Depending on the path taken, this can involve additional exchanges of value, which occur atomically.) This transaction type can be used for several types of payments.
    /// </summary>
    public sealed partial class PaymentTransaction : Transaction
    {
        /// <summary>
        /// The amount of currency to deliver. For non-XRP amounts, the nested field names MUST be lower-case. If the tfPartialPayment flag is set, deliver up to this amount instead.
        /// </summary>
        public Amount Amount { get; set; }

        /// <summary>
        /// The unique address of the account receiving the payment.
        /// </summary>
        public AccountId Destination { get; set; }

        /// <summary>
        /// (Optional) Arbitrary tag that identifies the reason for the payment to the destination, or a hosted recipient to pay.
        /// </summary>
        public uint? DestinationTag { get; set; }

        /// <summary>
        /// (Optional) Arbitrary 256-bit hash representing a specific reason or identifier for this payment.
        /// </summary>
        public Hash256? InvoiceID { get; set; }

        /// <summary>
        /// (Optional) Array of payment paths to be used for this transaction. Must be omitted for XRP-to-XRP transactions.
        /// </summary>
        public PathSet Paths { get; set; }

        /// <summary>
        /// (Optional) Highest amount of source currency this transaction is allowed to cost, including transfer fees, exchange rates, and slippage. Does not include the XRP destroyed as a cost for submitting the transaction. For non-XRP amounts, the nested field names MUST be lower-case. Must be supplied for cross-currency/cross-issue payments. Must be omitted for XRP-to-XRP payments.
        /// </summary>
        public Amount? SendMax { get; set; }

        /// <summary>
        /// (Optional) Minimum amount of destination currency this transaction should deliver. Only valid if this is a partial payment. For non-XRP amounts, the nested field names are lower-case.
        /// </summary>
        public Amount? DeliverMin { get; set; }

        public PaymentTransaction()
        {
        }

        internal PaymentTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "Payment")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Payment\"", "json");
            }
            JsonElement element;

            Amount = Ripple.Amount.ReadJson(json.GetProperty("Amount"));
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
            if (json.TryGetProperty("InvoiceID", out element))
            {
                InvoiceID = new Hash256(element.GetString());
            }
            if (json.TryGetProperty("Paths", out element))
            {
                Paths = new PathSet(element);
            }
            if (json.TryGetProperty("SendMax", out element))
            {
                SendMax = Ripple.Amount.ReadJson(element);
            }
            if (json.TryGetProperty("DeliverMin", out element))
            {
                DeliverMin = Ripple.Amount.ReadJson(element);
            }
        }

        internal PaymentTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_InvoiceID)
            {
                InvoiceID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Amount_SendMax)
            {
                SendMax = reader.ReadAmount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Amount_DeliverMin)
            {
                DeliverMin = reader.ReadAmount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
            if (fieldId == StFieldId.PathSet_Paths)
            {
                Paths = reader.ReadPathSet();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.Payment);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (DestinationTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.DestinationTag, DestinationTag.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            if (InvoiceID != null)
            {
                writer.WriteHash256(StHash256FieldCode.InvoiceID, InvoiceID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Amount, Amount);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            if (SendMax != null)
            {
                writer.WriteAmount(StAmountFieldCode.SendMax, SendMax.Value);
            }
            if (DeliverMin != null)
            {
                writer.WriteAmount(StAmountFieldCode.DeliverMin, DeliverMin.Value);
            }
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Destination, Destination);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
            if (Paths != null)
            {
                writer.WritePathSet(StPathSetFieldCode.Paths, Paths);
            }
        }
    }

    /// <summary>
    /// Claim XRP from a payment channel, adjust the payment channel's expiration, or both.
    /// </summary>
    public sealed partial class PaymentChannelClaimTransaction : Transaction
    {
        /// <summary>
        /// The unique ID of the channel, as a 64-character hexadecimal string.
        /// </summary>
        public Hash256 Channel { get; set; }

        /// <summary>
        /// (Optional) Total amount of XRP, in drops, delivered by this channel after processing this claim. Required to deliver XRP. Must be more than the total amount delivered by the channel so far, but not greater than the Amount of the signed claim. Must be provided except when closing the channel.
        /// </summary>
        public XrpAmount? Balance { get; set; }

        /// <summary>
        /// (Optional) The amount of XRP, in drops, authorized by the Signature. This must match the amount in the signed message. This is the cumulative amount of XRP that can be dispensed by the channel, including XRP previously redeemed.
        /// </summary>
        public XrpAmount? Amount { get; set; }

        /// <summary>
        /// (Optional) The signature of this claim, as hexadecimal. The signed message contains the channel ID and the amount of the claim. Required unless the sender of the transaction is the source address of the channel.
        /// </summary>
        public ReadOnlyMemory<byte>? Signature { get; set; }

        /// <summary>
        /// (Optional) The public key used for the signature, as hexadecimal. This must match the PublicKey stored in the ledger for the channel. Required unless the sender of the transaction is the source address of the channel and the Signature field is omitted. (The transaction includes the public key so that rippled can check the validity of the signature before trying to apply the transaction to the ledger.)
        /// </summary>
        public ReadOnlyMemory<byte>? PublicKey { get; set; }

        public PaymentChannelClaimTransaction()
        {
        }

        internal PaymentChannelClaimTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "PaymentChannelClaim")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"PaymentChannelClaim\"", "json");
            }
            JsonElement element;

            Channel = new Hash256(json.GetProperty("Channel").GetString());
            if (json.TryGetProperty("Balance", out element))
            {
                Balance = Ripple.XrpAmount.ReadJson(element);
            }
            if (json.TryGetProperty("Amount", out element))
            {
                Amount = Ripple.XrpAmount.ReadJson(element);
            }
            if (json.TryGetProperty("Signature", out element))
            {
                Signature = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("PublicKey", out element))
            {
                PublicKey = element.GetBytesFromBase16();
            }
        }

        internal PaymentChannelClaimTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_Channel)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_Channel, fieldId));
            }
            Channel = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Amount_Amount)
            {
                Amount = reader.ReadXrpAmount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Amount_Balance)
            {
                Balance = reader.ReadXrpAmount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_PublicKey)
            {
                PublicKey = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Signature)
            {
                Signature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.PaymentChannelClaim);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteHash256(StHash256FieldCode.Channel, Channel);
            if (Amount != null)
            {
                writer.WriteAmount(StAmountFieldCode.Amount, Amount.Value);
            }
            if (Balance != null)
            {
                writer.WriteAmount(StAmountFieldCode.Balance, Balance.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            if (PublicKey != null)
            {
                writer.WriteBlob(StBlobFieldCode.PublicKey, PublicKey.Value.Span);
            }
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            if (!forSigning)
            {
                if (Signature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.Signature, Signature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Create a unidirectional channel and fund it with XRP. The address sending this transaction becomes the "source address" of the payment channel.
    /// </summary>
    public sealed partial class PaymentChannelCreateTransaction : Transaction
    {
        /// <summary>
        /// Amount of XRP, in drops, to deduct from the sender's balance and set aside in this channel. While the channel is open, the XRP can only go to the Destination address. When the channel closes, any unclaimed XRP is returned to the source address's balance.
        /// </summary>
        public XrpAmount Amount { get; set; }

        /// <summary>
        /// Address to receive XRP claims against this channel. This is also known as the "destination address" for the channel. Cannot be the same as the sender (Account).
        /// </summary>
        public AccountId Destination { get; set; }

        /// <summary>
        /// Amount of time the source address must wait before closing the channel if it has unclaimed XRP.
        /// </summary>
        public TimeSpan SettleDelay { get; set; }

        /// <summary>
        /// The public key of the key pair the source will use to sign claims against this channel, in hexadecimal. This can be any secp256k1 or Ed25519 public key.
        /// </summary>
        public ReadOnlyMemory<byte> PublicKey { get; set; }

        /// <summary>
        /// (Optional) The time, in seconds since the Ripple Epoch, when this channel expires. Any transaction that would modify the channel after this time closes the channel without otherwise affecting it. This value is immutable; the channel can be closed earlier than this time but cannot remain open after this time.
        /// </summary>
        public DateTimeOffset? CancelAfter { get; set; }

        /// <summary>
        /// (Optional) Arbitrary tag to further specify the destination for this payment channel, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; set; }

        public PaymentChannelCreateTransaction()
        {
        }

        internal PaymentChannelCreateTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "PaymentChannelCreate")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"PaymentChannelCreate\"", "json");
            }
            JsonElement element;

            Amount = Ripple.XrpAmount.ReadJson(json.GetProperty("Amount"));
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            SettleDelay = TimeSpan.FromSeconds(json.GetProperty("SettleDelay").GetUInt32());
            PublicKey = json.GetProperty("PublicKey").GetBytesFromBase16();
            if (json.TryGetProperty("CancelAfter", out element))
            {
                CancelAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
        }

        internal PaymentChannelCreateTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_CancelAfter)
            {
                CancelAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_SettleDelay)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SettleDelay, fieldId));
            }
            SettleDelay = TimeSpan.FromSeconds(reader.ReadUInt32());
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_PublicKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_PublicKey, fieldId));
            }
            PublicKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.PaymentChannelCreate);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (DestinationTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.DestinationTag, DestinationTag.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (CancelAfter != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.CancelAfter, Epoch.FromDateTimeOffset(CancelAfter.Value));
            }
            writer.WriteUInt32(StUInt32FieldCode.SettleDelay, (uint)SettleDelay.TotalSeconds);
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Amount, Amount);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.PublicKey, PublicKey.Span);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            writer.WriteAccount(StAccountIDFieldCode.Destination, Destination);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Add additional XRP to an open payment channel, and optionally update the expiration time of the channel. Only the source address of the channel can use this transaction.
    /// </summary>
    public sealed partial class PaymentChannelFundTransaction : Transaction
    {
        /// <summary>
        /// The unique ID of the channel, as a 64-character hexadecimal string.
        /// </summary>
        public Hash256 Channel { get; set; }

        /// <summary>
        /// Amount of XRP, in drops to add to the channel. Must be a positive amount of XRP.
        /// </summary>
        public XrpAmount Amount { get; set; }

        /// <summary>
        /// (Optional) New Expiration time to set for the channel, in seconds since the Ripple Epoch. This must be later than either the current time plus the SettleDelay of the channel, or the existing Expiration of the channel. After the Expiration time, any transaction that would access the channel closes the channel without taking its normal action. Any unspent XRP is returned to the source address when the channel closes. (Expiration is separate from the channel's immutable CancelAfter time.) For more information, see the PayChannel ledger object type.
        /// </summary>
        public DateTimeOffset? Expiration { get; set; }

        public PaymentChannelFundTransaction()
        {
        }

        internal PaymentChannelFundTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "PaymentChannelFund")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"PaymentChannelFund\"", "json");
            }
            JsonElement element;

            Channel = new Hash256(json.GetProperty("Channel").GetString());
            Amount = Ripple.XrpAmount.ReadJson(json.GetProperty("Amount"));
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
        }

        internal PaymentChannelFundTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_Channel)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_Channel, fieldId));
            }
            Channel = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.PaymentChannelFund);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (Expiration != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.Expiration, Epoch.FromDateTimeOffset(Expiration.Value));
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteHash256(StHash256FieldCode.Channel, Channel);
            writer.WriteAmount(StAmountFieldCode.Amount, Amount);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// A SetRegularKey transaction assigns, changes, or removes the regular key pair associated with an account.
    /// </summary>
    public sealed partial class SetRegularKeyTransaction : Transaction
    {
        /// <summary>
        /// (Optional) A base-58-encoded Address that indicates the regular key pair to be assigned to the account. If omitted, removes any existing regular key pair from the account. Must not match the master key pair for the address.
        /// </summary>
        public AccountId? RegularKey { get; set; }

        public SetRegularKeyTransaction()
        {
        }

        internal SetRegularKeyTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "SetRegularKey")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"SetRegularKey\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("RegularKey", out element))
            {
                RegularKey = new AccountId(element.GetString());
            }
        }

        internal SetRegularKeyTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.AccountID_RegularKey)
            {
                RegularKey = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.SetRegularKey);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (RegularKey != null)
            {
                writer.WriteAccount(StAccountIDFieldCode.RegularKey, RegularKey.Value);
            }
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// The SignerListSet transaction creates, replaces, or removes a list of signers that can be used to multi-sign a transaction. This transaction type was introduced by the MultiSign amendment. New in: rippled 0.31.0
    /// </summary>
    public sealed partial class SignerListSetTransaction : Transaction
    {
        /// <summary>
        /// A target number for the signer weights. A multi-signature from this list is valid only if the sum weights of the signatures provided is greater than or equal to this value. To delete a signer list, use the value 0.
        /// </summary>
        public uint SignerQuorum { get; set; }

        /// <summary>
        /// (Omitted when deleting) Array of SignerEntry objects, indicating the addresses and weights of signers in this list. This signer list must have at least 1 member and no more than 8 members. No address may appear more than once in the list, nor may the Account submitting the transaction appear in the list.
        /// </summary>
        public ReadOnlyCollection<SignerEntry> SignerEntries { get; set; }

        public SignerListSetTransaction()
        {
        }

        internal SignerListSetTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "SignerListSet")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"SignerListSet\"", "json");
            }
            JsonElement element;

            SignerQuorum = json.GetProperty("SignerQuorum").GetUInt32();
            element = json.GetProperty("SignerEntries");
            var SignerEntriesArray = new SignerEntry[element.GetArrayLength()];
            for (int i = 0; i < SignerEntriesArray.Length; ++i)
            {
                SignerEntriesArray[i] = new SignerEntry(element[i]);
            }
            SignerEntries = Array.AsReadOnly(SignerEntriesArray);
        }

        internal SignerListSetTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_SignerQuorum)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SignerQuorum, fieldId));
            }
            SignerQuorum = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            throw new Exception("End of st data reached but non-optional fields still not set");
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId != StFieldId.Array_SignerEntries)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Array_SignerEntries, fieldId));
            }
            var SignerEntriesList = new System.Collections.Generic.List<SignerEntry>();
            while (true)
            {
                fieldId = reader.ReadFieldId();
                if (fieldId == StFieldId.Array_ArrayEndMarker)
                {
                    if (!reader.TryReadFieldId(out fieldId))
                    {
                        return;
                    }
                    break;
                }
                if (fieldId != StFieldId.Object_SignerEntry)
                {
                    throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_SignerEntry, fieldId));
                }
                SignerEntriesList.Add(new SignerEntry(ref reader));
            }
            SignerEntries = SignerEntriesList.AsReadOnly();
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.SignerListSet);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.SignerQuorum, SignerQuorum);
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            writer.WriteStartArray(StArrayFieldCode.SignerEntries);
            foreach(var entry in SignerEntries)
            {
                entry.WriteTo(ref writer);
            }
            writer.WriteEndArray();
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// A TicketCreate transaction sets aside one or more sequence numbers as Tickets.
    /// </summary>
    public sealed partial class TicketCreateTransaction : Transaction
    {
        /// <summary>
        /// How many Tickets to create. This must be a positive number and cannot cause the account to own more than 250 Tickets after executing this transaction.
        /// </summary>
        public uint TicketCount { get; set; }

        public TicketCreateTransaction()
        {
        }

        internal TicketCreateTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "TicketCreate")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"TicketCreate\"", "json");
            }

            TicketCount = json.GetProperty("TicketCount").GetUInt32();
        }

        internal TicketCreateTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_TicketCount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_TicketCount, fieldId));
            }
            TicketCount = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.TicketCreate);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.TicketCount, TicketCount);
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

    /// <summary>
    /// Create or modify a trust line linking two accounts.
    /// </summary>
    public sealed partial class TrustSetTransaction : Transaction
    {
        /// <summary>
        /// Object defining the trust line to create or modify, in the format of a Currency Amount.
        /// </summary>
        public IssuedAmount LimitAmount { get; set; }

        /// <summary>
        /// (Optional) Value incoming balances on this trust line at the ratio of this number per 1,000,000,000 units. A value of 0 is shorthand for treating balances at face value.
        /// </summary>
        public uint? QualityIn { get; set; }

        /// <summary>
        /// (Optional) Value outgoing balances on this trust line at the ratio of this number per 1,000,000,000 units. A value of 0 is shorthand for treating balances at face value.
        /// </summary>
        public uint? QualityOut { get; set; }

        public TrustSetTransaction()
        {
        }

        internal TrustSetTransaction(JsonElement json): base(json)
        {
            if (json.GetProperty("TransactionType").GetString() != "TrustSet")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"TrustSet\"", "json");
            }
            JsonElement element;

            LimitAmount = Ripple.IssuedAmount.ReadJson(json.GetProperty("LimitAmount"));
            if (json.TryGetProperty("QualityIn", out element))
            {
                QualityIn = element.GetUInt32();
            }
            if (json.TryGetProperty("QualityOut", out element))
            {
                QualityOut = element.GetUInt32();
            }
        }

        internal TrustSetTransaction(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.UInt32_Flags)
            {
                base.Flags = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_QualityIn)
            {
                QualityIn = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_QualityOut)
            {
                QualityOut = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LastLedgerSequence)
            {
                LastLedgerSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_TicketSequence)
            {
                TicketSequence = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_LimitAmount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_LimitAmount, fieldId));
            }
            LimitAmount = reader.ReadIssuedAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Fee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Fee, fieldId));
            }
            Fee = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_SigningPubKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_SigningPubKey, fieldId));
            }
            SigningPubKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_TxnSignature)
            {
                TxnSignature = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Signers)
            {
                var SignersList = new System.Collections.Generic.List<Signer>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Signer)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Signer, fieldId));
                    }
                    SignersList.Add(new Signer(ref reader));
                }
                Signers = SignersList.AsReadOnly();
            }
            if (fieldId == StFieldId.Array_Memos)
            {
                var MemosList = new System.Collections.Generic.List<Memo>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_Memo)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Memo, fieldId));
                    }
                    MemosList.Add(new Memo(ref reader));
                }
                Memos = MemosList.AsReadOnly();
            }
        }

        private protected override void Serialize(IBufferWriter<byte> bufferWriter, bool forSigning)
        {
            var writer = new StWriter(bufferWriter);
            writer.WriteTransactionType(StTransactionType.TrustSet);
            if (base.Flags != 0u)
            {
                writer.WriteUInt32(StUInt32FieldCode.Flags, base.Flags);
            }
            if (SourceTag != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.SourceTag, SourceTag.Value);
            }
            writer.WriteUInt32(StUInt32FieldCode.Sequence, Sequence);
            if (QualityIn != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.QualityIn, QualityIn.Value);
            }
            if (QualityOut != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.QualityOut, QualityOut.Value);
            }
            if (LastLedgerSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.LastLedgerSequence, LastLedgerSequence.Value);
            }
            if (TicketSequence != null)
            {
                writer.WriteUInt32(StUInt32FieldCode.TicketSequence, TicketSequence.Value);
            }
            if (AccountTxnID != null)
            {
                writer.WriteHash256(StHash256FieldCode.AccountTxnID, AccountTxnID.Value);
            }
            writer.WriteAmount(StAmountFieldCode.LimitAmount, LimitAmount);
            writer.WriteAmount(StAmountFieldCode.Fee, Fee);
            writer.WriteBlob(StBlobFieldCode.SigningPubKey, SigningPubKey.Span);
            if (!forSigning)
            {
                if (TxnSignature != null)
                {
                    writer.WriteBlob(StBlobFieldCode.TxnSignature, TxnSignature.Value.Span);
                }
            }
            writer.WriteAccount(StAccountIDFieldCode.Account, Account);
            if (!forSigning)
            {
                if (Signers != null)
                {
                    writer.WriteStartArray(StArrayFieldCode.Signers);
                    foreach(var entry in Signers)
                    {
                        entry.WriteTo(ref writer);
                    }
                    writer.WriteEndArray();
                }
            }
            if (Memos != null)
            {
                writer.WriteStartArray(StArrayFieldCode.Memos);
                foreach(var entry in Memos)
                {
                    entry.WriteTo(ref writer);
                }
                writer.WriteEndArray();
            }
        }
    }

}

